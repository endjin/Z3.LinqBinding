#!csharp

#r "Z3.LinqBinding\bin\Release\net6.0\Z3.LinqBinding.dll"
#r "Z3.LinqBinding.Sudoku\bin\Release\net6.0\Z3.LinqBinding.Sudoku.dll"
#r "nuget:Microsoft.Z3"
#r "nuget:MiaPlaza.ExpressionUtils"

#!csharp

using System;
using System.Diagnostics;
using Z3.LinqBinding;
using Z3.LinqBinding.Sudoku;

#!csharp

using (var ctx = new Z3Context())
{
    var theorem = from t in ctx.NewTheorem<(bool x, bool y)>()
                    where t.x ^ t.y
                    select t;

    var result = theorem.Solve();

    Console.WriteLine(result);
}

#!markdown

SudokuTheorem Example from https://sandiway.arizona.edu/sudoku/examples.html

#!csharp

using (var ctx = new Z3Context())
{
    var theorem = from t in SudokuTheorem.Create(ctx)
                  where t.Cell14 == 2 && t.Cell15 == 6 && t.Cell17 == 7 && t.Cell19 == 1
                  where t.Cell21 == 6 && t.Cell22 == 8 && t.Cell25 == 7 && t.Cell28 == 9
                  where t.Cell31 == 1 && t.Cell32 == 9 && t.Cell36 == 4 && t.Cell37 == 5
                  where t.Cell41 == 8 && t.Cell42 == 2 && t.Cell44 == 1 && t.Cell48 == 4
                  where t.Cell53 == 4 && t.Cell54 == 6 && t.Cell56 == 2 && t.Cell57 == 9
                  where t.Cell62 == 5 && t.Cell66 == 3 && t.Cell68 == 2 && t.Cell69 == 8
                  where t.Cell73 == 9 && t.Cell74 == 3 && t.Cell78 == 7 && t.Cell79 == 4
                  where t.Cell82 == 4 && t.Cell85 == 5 && t.Cell88 == 3 && t.Cell89 == 6
                  where t.Cell91 == 7 && t.Cell93 == 3 && t.Cell95 == 1 && t.Cell96 == 8
                  select t;

    var result = theorem.Solve();
    Console.WriteLine(result);
}

#!csharp

SolverContext context = SolverContext.GetContext();
context.ClearModel();
Model model = context.CreateModel();

Decision sa = new Decision(Domain.RealRange(0, 9000), "SA");
Decision vz = new Decision(Domain.RealRange(0, 6000), "VZ");
model.AddDecisions(sa, vz);

model.AddGoal("goal", GoalKind.Minimize, 20 * sa + 15 * vz);

model.AddConstraint("demand1", 0.3 * sa + 0.4 * vz >= 1900);
model.AddConstraint("demand2", 0.4 * sa + 0.2 * vz >= 1500);
model.AddConstraint("demand3", 0.2 * sa + 0.3 * vz >= 500);

Solution solution = context.Solve(new SimplexDirective());
Report report = solution.GetReport();
Console.WriteLine(report);

#!csharp

using (var ctx = new Z3Context())
{
    // ctx.Log = Console.Out;

    var theorem = from t in ctx.NewTheorem<(double vz, double sa)>()
                    where 0.3 * t.sa + 0.4 * t.vz >= 1900
                    where 0.4 * t.sa + 0.2 * t.vz >= 1500
                    where 0.2 * t.sa + 0.3 * t.vz >= 500
                    where 0 <= t.sa && t.sa <= 9000
                    where 0 <= t.vz && t.vz <= 6000
                    //orderby 20 * t.sa + 15 * t.vz // we need to turn order by into goals
                    select t;

    var result = theorem.Solve();

    Console.WriteLine(result);
}

#!csharp

public class Coordinate 
{
  public int Name { get; set; }

  // X-coordinate (from TSPLIB)
  public double X { get; set; }

  // Y-coordinate (from TSPLIB)
  public double Y { get; set; }

  public Coordinate(int name, double x, double y) 
  {
    Name = name;
    X = x;
    Y = y;
  }

  // Latitude in radians.
  public double Latitude 
  {
    get { return Math.PI * (Math.Truncate(X) + 5 * (X - Math.Truncate(X)) / 3) / 180; }
  }

  // Longitude in radians.
  public double Longitude 
  {
    get { return Math.PI * (Math.Truncate(Y) + 5 * (Y - Math.Truncate(Y)) / 3) / 180; }
  }

  // Geographic distance between two points (as an integer).
  public int Distance(Coordinate p) 
  {
    double q1 = Math.Cos(Longitude - p.Longitude);
    double q2 = Math.Cos(Latitude - p.Latitude);
    double q3 = Math.Cos(Latitude + p.Latitude);
    // There may rounding difficulties her if the points are close together...just sayin'.
    return (int)(6378.388 * Math.Acos(0.5 * ((1 + q1) * q2 - (1 - q1) * q3)) + 1);
  }
}

#!markdown

https://nathanbrixius.wordpress.com/2009/04/27/solving-traveling-salesman-problems-using-solver-foundation/
https://nathanbrixius.wordpress.com/2010/04/26/traveling-salesman-problems-using-solver-foundation-c-code/

#!csharp

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
// using Microsoft.SolverFoundation.Services;

#!csharp

public class Coordinate 
{
  public int Name { get; set; }

  // X-coordinate (from TSPLIB)
  public double X { get; set; }

  // Y-coordinate (from TSPLIB)
  public double Y { get; set; }

  public Coordinate(int name, double x, double y) 
  {
    Name = name;
    X = x;
    Y = y;
  }

  // Latitude in radians.
  public double Latitude 
  {
    get { return Math.PI * (Math.Truncate(X) + 5 * (X - Math.Truncate(X)) / 3) / 180; }
  }

  // Longitude in radians.
  public double Longitude 
  {
    get { return Math.PI * (Math.Truncate(Y) + 5 * (Y - Math.Truncate(Y)) / 3) / 180; }
  }

  // Geographic distance between two points (as an integer).
  public int Distance(Coordinate p) 
  {
    double q1 = Math.Cos(Longitude - p.Longitude);
    double q2 = Math.Cos(Latitude - p.Latitude);
    double q3 = Math.Cos(Latitude + p.Latitude);

    // There may rounding difficulties her if the points are close together....
    return (int)(6378.388 * Math.Acos(0.5 * ((1 + q1) * q2 - (1 - q1) * q3)) + 1);
  }
}

#!csharp

public class Arc 
{
    public int City1 { get; set; }
    public int City2 { get; set; }
    public double Distance { get; set; }
}

#!csharp

Coordinate[] data = new Coordinate[] 
{
    new Coordinate(0, 16.47, 96.10),
    new Coordinate(1, 16.47, 94.44),
    new Coordinate(2, 20.09, 92.54),
    new Coordinate(3, 22.39, 93.37),
    new Coordinate(4, 25.23, 97.24),
    new Coordinate(5, 22.00, 96.05),
    new Coordinate(6, 20.47, 97.02),
    new Coordinate(7, 17.20, 96.29),
    new Coordinate(8, 16.30, 97.38),
    new Coordinate(9, 14.05, 98.12),
    new Coordinate(10, 16.53, 97.38),
    new Coordinate(11, 21.52, 95.59),
    new Coordinate(12, 19.41, 97.13),
    new Coordinate(13, 20.09, 94.55)
};

#!csharp

SolverContext context = SolverContext.GetContext();
Model model = context.CreateModel();

// Parameters
Set city = new Set(Domain.IntegerNonnegative, "city");
Parameter dist = new Parameter(Domain.Real, "dist", city, city);

var arcs = from p1 in data
           from p2 in data
           select new Arc { City1 = p1.Name, City2 = p2.Name, Distance = p1.Distance(p2) };

dist.SetBinding(arcs, "Distance", "City1", "City2");

model.AddParameters(dist);

// Decisions
Decision assign = new Decision(Domain.IntegerRange(0, 1), "assign", city, city);
Decision rank = new Decision(Domain.RealNonnegative, "rank", city);

model.AddDecisions(assign, rank);

// Goal: minimize the length of the tour.
Goal goal = model.AddGoal("TourLength", GoalKind.Minimize, Model.Sum(Model.ForEach(city, i => Model.ForEachWhere(city, j => dist[i, j] * assign[i, j], j => i != j))));

// Enter and leave each city only once.
int N = data.Length;
model.AddConstraint("assign_1", Model.ForEach(city, i => Model.Sum(Model.ForEachWhere(city, j => assign[i, j], j => i != j)) == 1));
model.AddConstraint("assign_2", Model.ForEach(city, j => Model.Sum(Model.ForEachWhere(city, i => assign[i, j], i => i != j)) == 1));

// Forbid subtours (Miller, Tucker, Zemlin - 1960...)
model.AddConstraint("no_subtours",
  Model.ForEach(city, i => Model.ForEachWhere(city,
      j => rank[i] + 1 <= rank[j] + N * (1 - assign[i, j]),
      j => Model.And(i != j, i >= 1, j >= 1)
    )
  )
);

Solution solution = context.Solve();

// Retrieve solution information.
Console.WriteLine("Cost = {0}", goal.ToDouble());
Console.WriteLine("Tour:");

var tour = from p in assign.GetValues() where (double)p[0] > 0.9 select p[2];

foreach (var i in tour.ToArray()) 
{
  Console.Write(i + " -> ");
}

// Alternative Approach
var tour2 = from p in assign.GetValues() where (double)p[0] > 0.9 select p;

foreach (var t in tour2)
{
  Console.WriteLine($"{t[1]} -> {t[2]}");
}

#!markdown

https://nathanbrixius.wordpress.com/2009/04/24/modeling-a-production-planning-problem-using-solver-foundation/

#!markdown

In this example we have two refineries (located in Saudi Arabia and Venzuela) that produce three products: gasoline, jet fuel, and lubricant. 

The goal is to minimize production costs, which depend on location. There is demand for each product which must be met. Finally, each production site has a limited production capacity.

#!csharp

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
// using Microsoft.SolverFoundation.Services;

#!csharp

SolverContext context = SolverContext.GetContext();
context.ClearModel();
Model model = context.CreateModel();

Decision sa = new Decision(Domain.RealRange(0, 9000), "SA");
Decision vz = new Decision(Domain.RealRange(0, 6000), "VZ");
model.AddDecisions(sa, vz);

model.AddGoal("goal", GoalKind.Minimize, 20 * sa + 15 * vz);

model.AddConstraint("demand1", 0.3 * sa + 0.4 * vz >= 1900);
model.AddConstraint("demand2", 0.4 * sa + 0.2 * vz >= 1500);
model.AddConstraint("demand3", 0.2 * sa + 0.3 * vz >= 500);

Solution solution = context.Solve(new SimplexDirective());
Report report = solution.GetReport();
Console.WriteLine(report);

#!markdown

2nd Example using data...

#!csharp

static DataSet GetData() 
{
    string[] products = new string[] { "Gas", "Jet Fuel", "Lubricant" };
    string[] countries = new string[] { "SA", "VZ" };

    double[][] yield = new double[][] 
    {
      new double[] { 0.3, 0.4 }, 
      new double[] { 0.4, 0.2 }, 
      new double[] { 0.2, 0.3 } 
    };

    double[] demand = new double[] { 1900, 1500, 500 };
    double[] limit = new double[] { 9000, 6000 };
    double[] cost = new double[] { 20, 15 };

    DataSet dataSet = new DataSet();
    DataTable table = new DataTable("Yield");
    dataSet.Tables.Add(table);

    table.Columns.Add("Product", typeof(string));
    table.Columns.Add("Country", typeof(string));
    table.Columns.Add("Yield", typeof(double));

    for (int p = 0; p < products.Length; p++) {
      for (int c = 0; c < countries.Length; c++) {
        DataRow row = table.NewRow();
        row[0] = products[p];
        row[1] = countries[c];
        row[2] = yield[p][c];
        table.Rows.Add(row);
      }
    }

    table = new DataTable("Demand");
    dataSet.Tables.Add(table);
    table.Columns.Add("Product", typeof(string));
    table.Columns.Add("Demand", typeof(double));

    for (int p = 0; p < products.Length; p++) {
      DataRow row = table.NewRow();
      row[0] = products[p];
      row[1] = demand[p];
      table.Rows.Add(row);
    }

    table = new DataTable("Limit");
    dataSet.Tables.Add(table);
    table.Columns.Add("Country", typeof(string));
    table.Columns.Add("Limit", typeof(double));

    for (int c = 0; c < countries.Length; c++) 
    {
      DataRow row = table.NewRow();
      row[0] = countries[c];
      row[1] = limit[c];
      table.Rows.Add(row);
    }

    table = new DataTable("Cost");
    dataSet.Tables.Add(table);
    table.Columns.Add("Country", typeof(string));
    table.Columns.Add("Cost", typeof(double));

    for (int c = 0; c < countries.Length; c++) 
    {
      DataRow row = table.NewRow();
      row[0] = countries[c];
      row[1] = cost[c];
      table.Rows.Add(row);
    }
    
    return dataSet;
}

#!csharp

SolverContext context = SolverContext.GetContext();
context.ClearModel(); 
Model model = context.CreateModel();

// Retrieve the problem data.
DataSet data = GetData();

Set products = new Set(Domain.Any, "products");
Set countries = new Set(Domain.Any, "countries");

Parameter demand = new Parameter(Domain.Real, "demand", products);
demand.SetBinding(data.Tables["Demand"].AsEnumerable(), "Demand", "Product");

Parameter yield = new Parameter(Domain.Real, "yield", products, countries);
yield.SetBinding(data.Tables["Yield"].AsEnumerable(), "Yield", "Product", "Country");

Parameter limit = new Parameter(Domain.Real, "limit", countries);
limit.SetBinding(data.Tables["Limit"].AsEnumerable(), "Limit", "Country");

Parameter cost = new Parameter(Domain.Real, "cost", countries);
cost.SetBinding(data.Tables["Cost"].AsEnumerable(), "Cost", "Country");

model.AddParameters(demand, yield, limit, cost);

Decision produce = new Decision(Domain.RealNonnegative, "produce", countries);
model.AddDecision(produce);

model.AddGoal("Goal", GoalKind.Minimize, Model.Sum(Model.ForEach(countries, c => cost[c] * produce[c])));

model.AddConstraint("Demand", 
    Model.ForEach(products, p => Model.Sum(Model.ForEach(countries, c => yield[p, c] * produce[c])) >= demand[p])
);

model.AddConstraint("ProductionLimit",
    Model.ForEach(countries, c => produce[c] <= limit[c])
);

Solution solution = context.Solve(new SimplexDirective());
Report report = solution.GetReport();

Console.WriteLine(report);
